<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="es"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JwtFilter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">G07-EsiMedia-PI-User-Backend</a> &gt; <a href="index.source.html" class="el_package">com.esimedia.shared.config</a> &gt; <span class="el_source">JwtFilter.java</span></div><h1>JwtFilter.java</h1><pre class="source lang-java linenums">package com.esimedia.shared.config;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import com.esimedia.features.auth.entity.Usuario;
import com.esimedia.features.auth.services.SesionService;
import com.esimedia.features.user_management.services.UserRetrievalService;
import com.esimedia.shared.util.JwtValidationUtil;

import io.jsonwebtoken.JwtException;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;


@Component
public class JwtFilter extends OncePerRequestFilter {
<span class="fc" id="L26">    private static final Logger jwtLogger = LoggerFactory.getLogger(JwtFilter.class);</span>

<span class="fc" id="L28">    private static final List&lt;String&gt; EXACT_STATIC_PATHS = Arrays.asList(&quot;/&quot;, &quot;&quot;);</span>
<span class="fc" id="L29">    private static final List&lt;String&gt; PREFIX_STATIC_PATHS = Arrays.asList(&quot;/favicon.ico&quot;, &quot;/static/&quot;, &quot;/assets/&quot;, &quot;/css/&quot;, &quot;/js/&quot;, &quot;/images/&quot;);</span>

    private final SesionService sesionService;
    private final JwtValidationUtil jwtValidationService;
    private final UserRetrievalService userRetrievalService;
    
<span class="fc" id="L35">    public JwtFilter(SesionService sesionService, JwtValidationUtil jwtValidationService, UserRetrievalService userRetrievalService) {</span>
<span class="fc" id="L36">        this.sesionService = sesionService;</span>
<span class="fc" id="L37">        this.jwtValidationService = jwtValidationService;</span>
<span class="fc" id="L38">        this.userRetrievalService = userRetrievalService;</span>
<span class="fc" id="L39">    }</span>

    @Override
    protected boolean shouldNotFilter(HttpServletRequest request) {
<span class="fc" id="L43">        String path = request.getRequestURI();</span>
<span class="fc" id="L44">        jwtLogger.info(&quot;[DEBUG] JwtFilter evaluando path: {}&quot;, path);</span>
<span class="fc" id="L45">        boolean excluded = false;</span>

        // Excluir raíz y rutas estáticas
<span class="fc bfc" id="L48" title="All 4 branches covered.">        if (EXACT_STATIC_PATHS.contains(path) || PREFIX_STATIC_PATHS.stream().anyMatch(path::startsWith)) {</span>
<span class="fc" id="L49">            excluded = true;</span>
        }
        
        // Excluir rutas públicas del filtro JWT
<span class="fc bfc" id="L53" title="All 4 branches covered.">        if (path.equals(&quot;/users/register/standard&quot;) || path.equals(&quot;/users/register/creator&quot;)) {</span>
<span class="fc" id="L54">            excluded = true;</span>
        }
<span class="fc bfc" id="L56" title="All 2 branches covered.">        if (path.startsWith(&quot;/users/register/confirm/&quot;)) {</span>
<span class="fc" id="L57">            excluded = true;</span>
        }
<span class="fc bfc" id="L59" title="All 6 branches covered.">        if (path.equals(&quot;/users/password/forgot&quot;) || path.equals(&quot;/users/password/reset&quot;) || path.equals(&quot;/users/password/forgot-privileged&quot;)) {</span>
<span class="fc" id="L60">            excluded = true;</span>
        }
<span class="fc bfc" id="L62" title="All 4 branches covered.">        if (path.equals(&quot;/users/auth/privileged-login&quot;) || path.equals(&quot;/users/auth/login&quot;)) {</span>
<span class="fc" id="L63">            excluded = true;</span>
        }
<span class="fc bfc" id="L65" title="All 6 branches covered.">        if (path.equals(&quot;/users/auth/step1&quot;) || path.equals(&quot;/users/auth/step2&quot;) || path.equals(&quot;/users/auth/step3&quot;)) {</span>
<span class="fc" id="L66">            excluded = true;</span>
        }
<span class="fc bfc" id="L68" title="All 4 branches covered.">        if (path.startsWith(&quot;/users/password/validate-reset-token/&quot;) || path.startsWith(&quot;/users/confirm/&quot;)) {</span>
<span class="fc" id="L69">            excluded = true;</span>
        }
<span class="fc bfc" id="L71" title="All 2 branches covered.">        if (path.startsWith(&quot;/content/&quot;)) {</span>
<span class="fc" id="L72">            excluded = true;</span>
        }

<span class="fc" id="L75">        jwtLogger.info(&quot;[DEBUG] shouldNotFilter para {}: {}&quot;, path, excluded);</span>
<span class="fc" id="L76">        return excluded;</span>
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        

<span class="nc" id="L84">        jwtLogger.debug(&quot;\n\n[DEBUG] Incoming {} {}\n\n&quot;, request.getMethod(), request.getRequestURI());</span>
<span class="nc" id="L85">        String requestPath = request.getRequestURI();</span>
<span class="nc" id="L86">        jwtLogger.debug(&quot;[DEBUG] JwtFilter procesando ruta protegida: {}&quot;, requestPath);</span>
        
        
        
        // Extraer y validar token una sola vez
<span class="nc" id="L91">        String authHeader = request.getHeader(&quot;Authorization&quot;);</span>
<span class="nc bnc" id="L92" title="All 4 branches missed.">        if (authHeader == null || !authHeader.startsWith(&quot;Bearer &quot;)) {</span>
<span class="nc" id="L93">            jwtLogger.warn(&quot;Protected endpoint accessed without token: {}&quot;, requestPath);</span>
<span class="nc" id="L94">            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, &quot;Token requerido&quot;);</span>
        }

        
        try {
<span class="nc" id="L99">            jwtValidationService.validarGenerico(authHeader);</span>
<span class="nc" id="L100">            String userId = jwtValidationService.validarGenerico(authHeader);</span>
<span class="nc" id="L101">            Usuario user = userRetrievalService.findAnyUserById(userId).orElse(null);</span>
<span class="nc bnc" id="L102" title="All 4 branches missed.">            if (user == null || user.getRol() == null) {</span>
<span class="nc" id="L103">                jwtLogger.warn(&quot;Usuario no encontrado para ID: {}&quot;, userId);</span>
<span class="nc" id="L104">                response.sendError(HttpServletResponse.SC_UNAUTHORIZED, &quot;Usuario no encontrado&quot;);</span>
            }


<span class="nc" id="L108">            jwtLogger.info(&quot;[DEBUG] Petición aceptada para la ruta: {}&quot;, requestPath);</span>

        } 
<span class="nc" id="L111">        catch (JwtException e) {</span>
<span class="nc" id="L112">            jwtLogger.error(&quot;Invalid or expired token for path: {}&quot;, requestPath, e);</span>
<span class="nc" id="L113">            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, &quot;Token inválido o expirado&quot;);</span>
        } 
<span class="nc" id="L115">        catch (Exception e) {</span>
<span class="nc" id="L116">            jwtLogger.error(&quot;Error inesperado en doFilterInternal para path: {}&quot;, requestPath, e);</span>
<span class="nc" id="L117">            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, &quot;Error interno&quot;);</span>
<span class="nc" id="L118">        }</span>
        
<span class="nc" id="L120">        filterChain.doFilter(request, response);</span>
<span class="nc" id="L121">    }</span>

    /**
     * Obtiene la IP real del cliente considerando proxies
     */
    private String getClientIp(HttpServletRequest request) {
<span class="nc" id="L127">        String xForwardedFor = request.getHeader(&quot;X-Forwarded-For&quot;);</span>
<span class="nc bnc" id="L128" title="All 4 branches missed.">        if (xForwardedFor != null &amp;&amp; !xForwardedFor.isEmpty()) {</span>
            // Tomar la primera IP en caso de múltiples
<span class="nc" id="L130">            return xForwardedFor.split(&quot;,&quot;)[0].trim();</span>
        }
<span class="nc" id="L132">        String xRealIp = request.getHeader(&quot;X-Real-IP&quot;);</span>
<span class="nc bnc" id="L133" title="All 4 branches missed.">        if (xRealIp != null &amp;&amp; !xRealIp.isEmpty()) {</span>
<span class="nc" id="L134">            return xRealIp;</span>
        }
<span class="nc" id="L136">        return request.getRemoteAddr();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>