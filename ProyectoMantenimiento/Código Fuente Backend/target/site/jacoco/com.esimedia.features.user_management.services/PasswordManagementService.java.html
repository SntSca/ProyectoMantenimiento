<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="es"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PasswordManagementService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">G07-EsiMedia-PI-User-Backend</a> &gt; <a href="index.source.html" class="el_package">com.esimedia.features.user_management.services</a> &gt; <span class="el_source">PasswordManagementService.java</span></div><h1>PasswordManagementService.java</h1><pre class="source lang-java linenums">package com.esimedia.features.user_management.services;

import java.security.SecureRandom;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Base64;
import java.util.Optional;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.web.server.ResponseStatusException;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import de.mkammerer.argon2.Argon2;
import de.mkammerer.argon2.Argon2Factory;

import com.esimedia.features.auth.enums.EstadoToken;
import com.esimedia.features.auth.enums.TipoToken;
import com.esimedia.features.auth.entity.Administrador;
import com.esimedia.features.auth.entity.CreadorContenido;
import com.esimedia.features.auth.entity.Token;
import com.esimedia.features.auth.entity.Usuario;
import com.esimedia.features.auth.entity.UsuarioNormal;
import com.esimedia.features.auth.services.EmailService;
import com.esimedia.features.auth.services.PasswordSecurityService;
import com.esimedia.features.user_management.dto.PasswordChangeDTO;
import com.esimedia.features.auth.repository.AdminRepository;
import com.esimedia.features.auth.repository.CreadorContenidoRepository;
import com.esimedia.features.auth.repository.TokenRepository;
import com.esimedia.features.auth.repository.UsuarioNormalRepository;

@Service
public class PasswordManagementService {

    private static final String USUARIO_NO_ENCONTRADO = &quot;Usuario no encontrado&quot;;
    private static final String CREADOR_NO_ENCONTRADO = &quot;Creador no encontrado&quot;;
    private static final String TOKEN_INVALIDO = &quot;Token de recuperaci칩n inv치lido&quot;;
    private static final String ERROR_INTERNO_RECUPERACION = &quot;Error interno durante la solicitud de recuperaci칩n&quot;;
    private static final String ERROR_INTERNO_RESET = &quot;Error interno durante el restablecimiento de contrase침a&quot;;
    private static final String CONTRASENA_ACTUAL_INCORRECTA = &quot;La contrase침a actual es incorrecta&quot;;
    private static final String CONTRASENA_DIFERENTE_REQUERIDA = &quot;Por favor, elige una contrase침a diferente a la actual&quot;;
    private static final String CONTRASENA_REUTILIZADA = &quot;La nueva contrase침a ya ha sido utilizada recientemente. Por favor, selecciona una contrase침a diferente.&quot;;
    private static final int PASSWORD_HISTORY_LIMIT = 5;

    private final UsuarioNormalRepository usuarioNormalRepository;
    private final CreadorContenidoRepository creadorContenidoRepository;
    private final AdminRepository adminRepository;
    private final TokenRepository tokenRepository;
    private final EmailService emailService;
    private final PasswordSecurityService passwordSecurityService;
    private final Logger logger;
<span class="fc" id="L54">    private final Argon2 argon2 = Argon2Factory.create(Argon2Factory.Argon2Types.ARGON2id);</span>

    @Value(&quot;${app.security.pepper}&quot;)
    private String pepper;

    @Value(&quot;${email.resetPasswordUrl}&quot;)
    private String resetPasswordUrl;

    public PasswordManagementService(UsuarioNormalRepository usuarioNormalRepository,
                                     CreadorContenidoRepository creadorContenidoRepository,
                                     AdminRepository adminRepository,
                                     TokenRepository tokenRepository,
                                     EmailService emailService,
<span class="fc" id="L67">                                     PasswordSecurityService passwordSecurityService) {</span>
<span class="fc" id="L68">        this.usuarioNormalRepository = usuarioNormalRepository;</span>
<span class="fc" id="L69">        this.creadorContenidoRepository = creadorContenidoRepository;</span>
<span class="fc" id="L70">        this.adminRepository = adminRepository;</span>
<span class="fc" id="L71">        this.tokenRepository = tokenRepository;</span>
<span class="fc" id="L72">        this.emailService = emailService;</span>
<span class="fc" id="L73">        this.passwordSecurityService = passwordSecurityService;</span>
<span class="fc" id="L74">        this.logger = LoggerFactory.getLogger(PasswordManagementService.class);</span>
<span class="fc" id="L75">    }</span>

    public void changePassword(String userId, PasswordChangeDTO passwordChangeDTO) {
        // Buscar el usuario en los tres tipos posibles
<span class="fc" id="L79">        Optional&lt;UsuarioNormal&gt; normalOpt = usuarioNormalRepository.findById(userId);</span>
<span class="fc bfc" id="L80" title="All 2 branches covered.">        if (normalOpt.isPresent()) {</span>
<span class="fc" id="L81">            changePasswordForNormal(normalOpt.get(), passwordChangeDTO);</span>
<span class="fc" id="L82">            return;</span>
        }
        
<span class="fc" id="L85">        Optional&lt;CreadorContenido&gt; creatorOpt = creadorContenidoRepository.findById(userId);</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">        if (creatorOpt.isPresent()) {</span>
<span class="fc" id="L87">            changePasswordForCreator(creatorOpt.get(), passwordChangeDTO);</span>
<span class="fc" id="L88">            return;</span>
        }
        
<span class="fc" id="L91">        Optional&lt;Administrador&gt; adminOpt = adminRepository.findById(userId);</span>
<span class="fc bfc" id="L92" title="All 2 branches covered.">        if (adminOpt.isPresent()) {</span>
<span class="fc" id="L93">            changePasswordForAdmin(adminOpt.get(), passwordChangeDTO);</span>
<span class="fc" id="L94">            return;</span>
        }
        
<span class="fc" id="L97">        throw new ResponseStatusException(HttpStatus.NOT_FOUND, USUARIO_NO_ENCONTRADO);</span>
    }

        private void changePasswordForNormal(UsuarioNormal user, PasswordChangeDTO passwordChangeDTO) {
<span class="fc" id="L101">        String oldPassword = passwordChangeDTO.getOldPassword();</span>
<span class="fc" id="L102">        String newPassword = passwordChangeDTO.getNewPassword();</span>
        
<span class="fc bfc" id="L104" title="All 2 branches covered.">        if (!matchesPassword(oldPassword, user.getPassword())) {</span>
<span class="fc" id="L105">            throw new ResponseStatusException(HttpStatus.UNAUTHORIZED, CONTRASENA_ACTUAL_INCORRECTA);</span>
        }

        // 游 No permitir reutilizar actual ni historial
<span class="fc" id="L109">        ensureNotReused(user, newPassword);</span>

<span class="fc" id="L111">        validatePasswordStrength(newPassword, user.getAlias(), user.getEmail());</span>
        
        // Guardar contrase침a actual en historial
<span class="fc" id="L114">        pushPasswordToHistory(user);</span>

<span class="fc" id="L116">        user.setPassword(encodePassword(newPassword));</span>
<span class="fc" id="L117">        user.setCredentialsVersion(user.getCredentialsVersion() + 1);</span>
<span class="fc" id="L118">        usuarioNormalRepository.save(user);</span>
        
<span class="fc" id="L120">        logger.info(&quot;Contrase침a cambiada exitosamente para el usuario normal con ID: {}&quot;, user.getIdUsuario());</span>
<span class="fc" id="L121">    }</span>


        private void changePasswordForCreator(CreadorContenido user, PasswordChangeDTO passwordChangeDTO) {
<span class="fc" id="L125">        String oldPassword = passwordChangeDTO.getOldPassword();</span>
<span class="fc" id="L126">        String newPassword = passwordChangeDTO.getNewPassword();</span>
        
<span class="fc bfc" id="L128" title="All 2 branches covered.">        if (!matchesPassword(oldPassword, user.getPassword())) {</span>
<span class="fc" id="L129">            throw new ResponseStatusException(HttpStatus.UNAUTHORIZED, CONTRASENA_ACTUAL_INCORRECTA);</span>
        }

        // 游 No permitir reutilizar actual ni historial
<span class="fc" id="L133">        ensureNotReused(user, newPassword);</span>

<span class="fc" id="L135">        validatePasswordStrength(newPassword, user.getAlias(), user.getEmail());</span>
        
<span class="fc" id="L137">        pushPasswordToHistory(user);</span>

<span class="fc" id="L139">        user.setPassword(encodePassword(newPassword));</span>
<span class="fc" id="L140">        user.setCredentialsVersion(user.getCredentialsVersion() + 1);</span>
<span class="fc" id="L141">        creadorContenidoRepository.save(user);</span>
        
<span class="fc" id="L143">        logger.info(&quot;Contrase침a cambiada exitosamente para el creador con ID: {}&quot;, user.getIdUsuario());</span>
<span class="fc" id="L144">    }</span>


        private void changePasswordForAdmin(Administrador user, PasswordChangeDTO passwordChangeDTO) {
<span class="fc" id="L148">        String oldPassword = passwordChangeDTO.getOldPassword();</span>
<span class="fc" id="L149">        String newPassword = passwordChangeDTO.getNewPassword();</span>
        
<span class="fc bfc" id="L151" title="All 2 branches covered.">        if (!matchesPassword(oldPassword, user.getPassword())) {</span>
<span class="fc" id="L152">            throw new ResponseStatusException(HttpStatus.UNAUTHORIZED, CONTRASENA_ACTUAL_INCORRECTA);</span>
        }

        // 游 No permitir reutilizar actual ni historial
<span class="fc" id="L156">        ensureNotReused(user, newPassword);</span>

<span class="fc" id="L158">        validatePasswordStrength(newPassword, user.getAlias(), user.getEmail());</span>
        
<span class="fc" id="L160">        pushPasswordToHistory(user);</span>

<span class="fc" id="L162">        user.setPassword(encodePassword(newPassword));</span>
<span class="fc" id="L163">        user.setCredentialsVersion(user.getCredentialsVersion() + 1);</span>
<span class="fc" id="L164">        adminRepository.save(user);</span>
        
<span class="fc" id="L166">        logger.info(&quot;Contrase침a cambiada exitosamente para el administrador con ID: {}&quot;, user.getIdUsuario());</span>
<span class="fc" id="L167">    }</span>


    public String requestPasswordResetGeneric(String email, String userType) {
        try {
<span class="fc" id="L172">            String userId = null;</span>
<span class="fc" id="L173">            String userEmail = null;</span>
<span class="fc" id="L174">            boolean isConfirmed = true;</span>

<span class="fc bfc" id="L176" title="All 4 branches covered.">            switch (userType) {</span>
                case &quot;normal&quot;: {
<span class="fc" id="L178">                    UsuarioNormal u = usuarioNormalRepository.findByemail(email)</span>
<span class="fc" id="L179">                        .orElseThrow(() -&gt; new ResponseStatusException(HttpStatus.NOT_FOUND, USUARIO_NO_ENCONTRADO));</span>
<span class="fc" id="L180">                    userId = u.getIdUsuario();</span>
<span class="fc" id="L181">                    userEmail = u.getEmail();</span>
<span class="fc" id="L182">                    isConfirmed = u.isConfirmado();</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">                    if (!isConfirmed) {</span>
<span class="fc" id="L184">                        throw new ResponseStatusException(HttpStatus.BAD_REQUEST, &quot;Debes validar tu cuenta antes de poder recuperar la contrase침a&quot;);</span>
                    }
                    break;
                }
                case &quot;creador&quot;: {
<span class="fc" id="L189">                    CreadorContenido c = creadorContenidoRepository.findByemail(email)</span>
<span class="fc" id="L190">                        .orElseThrow(() -&gt; new ResponseStatusException(HttpStatus.NOT_FOUND, CREADOR_NO_ENCONTRADO));</span>
<span class="fc" id="L191">                    userId = c.getIdUsuario();</span>
<span class="fc" id="L192">                    userEmail = c.getEmail();</span>
<span class="fc" id="L193">                    isConfirmed = c.isValidado();</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">                    if (!isConfirmed) {</span>
<span class="fc" id="L195">                        throw new ResponseStatusException(HttpStatus.BAD_REQUEST, &quot;El creador debe ser validado antes de recuperar la contrase침a&quot;);</span>
                    }
                    break;
                }
                case &quot;admin&quot;: {
<span class="fc" id="L200">                    Administrador a = adminRepository.findByemail(email)</span>
<span class="fc" id="L201">                        .orElseThrow(() -&gt; new ResponseStatusException(HttpStatus.NOT_FOUND, USUARIO_NO_ENCONTRADO));</span>
<span class="fc" id="L202">                    userId = a.getIdUsuario();</span>
<span class="fc" id="L203">                    userEmail = a.getEmail();</span>
<span class="fc" id="L204">                    break;</span>
                }
                default:
<span class="fc" id="L207">                    throw new ResponseStatusException(HttpStatus.BAD_REQUEST, &quot;Tipo de usuario no soportado&quot;);</span>
            }

<span class="fc" id="L210">            String resetToken = generateResetToken();</span>
<span class="fc" id="L211">            Token token = Token.builder()</span>
<span class="fc" id="L212">                .id(userId)</span>
<span class="fc" id="L213">                .tokenCreado(resetToken)</span>
<span class="fc" id="L214">                .tipoToken(TipoToken.RECUPERACION_PASSWORD)</span>
<span class="fc" id="L215">                .usuarioEmail(userEmail)</span>
<span class="fc" id="L216">                .fechaInicio(LocalDateTime.now())</span>
<span class="fc" id="L217">                .fechaUltimaActividad(LocalDateTime.now())</span>
<span class="fc" id="L218">                .estado(EstadoToken.SIN_CONFIRMAR)</span>
<span class="fc" id="L219">                .build();</span>
<span class="fc" id="L220">            tokenRepository.save(token);</span>

<span class="fc" id="L222">            String resetLink = resetPasswordUrl + resetToken;</span>
<span class="fc" id="L223">            String expirationTime = token.getFechaInicio().plusHours(24).format(DateTimeFormatter.ofPattern(&quot;dd/MM/yyyy 'a las' HH:mm&quot;));</span>
<span class="fc" id="L224">            emailService.resetEmail(userEmail, &quot;Recuperaci칩n de contrase침a&quot;, resetLink, expirationTime);</span>

<span class="fc" id="L226">            logger.info(&quot;Token de recuperaci칩n generado para usuario {} tipo {}: {}&quot;, userEmail, userType, resetToken);</span>
<span class="fc" id="L227">            return &quot;Se ha enviado un enlace de recuperaci칩n a tu correo electr칩nico&quot;;</span>
        } 
<span class="fc" id="L229">        catch (ResponseStatusException e) {</span>
<span class="fc" id="L230">            throw e;</span>
        } 
<span class="fc" id="L232">        catch (Exception e) {</span>
<span class="fc" id="L233">            logger.error(&quot;Error durante la solicitud de recuperaci칩n de contrase침a:&quot;, e);</span>
<span class="fc" id="L234">            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, ERROR_INTERNO_RECUPERACION);</span>
        }
    }

    @Transactional
    public String resetPassword(String tokenValue, String newPassword) {
        try {
<span class="fc" id="L241">            Optional&lt;Token&gt; resetTokenOpt = tokenRepository.findAll().stream()</span>
<span class="pc bpc" id="L242" title="3 of 6 branches missed.">                .filter(t -&gt; t.getTokenCreado() != null &amp;&amp; t.getTokenCreado().equals(tokenValue) &amp;&amp; t.getTipoToken() == TipoToken.RECUPERACION_PASSWORD)</span>
<span class="fc" id="L243">                .findFirst();</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">            if (resetTokenOpt.isEmpty()) {</span>
<span class="fc" id="L245">                throw new ResponseStatusException(HttpStatus.BAD_REQUEST, TOKEN_INVALIDO);</span>
            }
<span class="fc" id="L247">            Token resetToken = resetTokenOpt.get();</span>

<span class="fc bfc" id="L249" title="All 2 branches covered.">            if (!resetToken.isValido()) {</span>
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">                if (resetToken.isExpirado()) {</span>
<span class="fc" id="L251">                    tokenRepository.delete(resetToken);</span>
                }
<span class="fc" id="L253">                throw new ResponseStatusException(HttpStatus.BAD_REQUEST, TOKEN_INVALIDO);</span>
            }

<span class="fc" id="L256">            String userEmail = resetToken.getUsuarioEmail();</span>
<span class="fc" id="L257">            String userAlias = null;</span>
<span class="fc" id="L258">            boolean userFound = false;</span>

            // Buscar por ID en lugar de email para asegurar la tabla correcta
<span class="fc" id="L261">            Optional&lt;UsuarioNormal&gt; normalOpt = usuarioNormalRepository.findById(resetToken.getId());</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">            if (normalOpt.isPresent()) {</span>
<span class="fc" id="L263">                UsuarioNormal user = normalOpt.get();</span>
<span class="fc" id="L264">                userAlias = user.getAlias();</span>

                // 游 No permitir reutilizar actual ni historial
<span class="nc" id="L267">                ensureNotReused(user, newPassword);</span>

<span class="nc" id="L269">                validatePasswordStrength(newPassword, userAlias, userEmail);</span>

                // Guardar contrase침a actual en historial antes de cambiarla
<span class="nc" id="L272">                pushPasswordToHistory(user);</span>

<span class="nc" id="L274">                user.setPassword(encodePassword(newPassword));</span>
<span class="nc" id="L275">                usuarioNormalRepository.save(user);</span>
<span class="nc" id="L276">                logger.info(&quot;Contrase침a guardada exitosamente para UsuarioNormal: {}&quot;, userEmail);</span>
<span class="nc" id="L277">                userFound = true;</span>
            }


<span class="pc bpc" id="L281" title="1 of 2 branches missed.">            if (!userFound) {</span>
<span class="fc" id="L282">                Optional&lt;CreadorContenido&gt; creadorOpt = creadorContenidoRepository.findById(resetToken.getId());</span>
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">                if (creadorOpt.isPresent()) {</span>
<span class="nc" id="L284">                    CreadorContenido creador = creadorOpt.get();</span>
<span class="nc" id="L285">                    userAlias = creador.getAlias();</span>

<span class="nc" id="L287">                    ensureNotReused(creador, newPassword);</span>
<span class="nc" id="L288">                    validatePasswordStrength(newPassword, userAlias, userEmail);</span>
<span class="nc" id="L289">                    pushPasswordToHistory(creador);</span>

<span class="nc" id="L291">                    creador.setPassword(encodePassword(newPassword));</span>
<span class="nc" id="L292">                    creadorContenidoRepository.save(creador);</span>
<span class="nc" id="L293">                    logger.info(&quot;Contrase침a guardada exitosamente para CreadorContenido: {}&quot;, userEmail);</span>
<span class="nc" id="L294">                    userFound = true;</span>
                }
            }


<span class="pc bpc" id="L299" title="1 of 2 branches missed.">            if (!userFound) {</span>
<span class="fc" id="L300">                Optional&lt;Administrador&gt; adminOpt = adminRepository.findById(resetToken.getId());</span>
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">                if (adminOpt.isPresent()) {</span>
<span class="nc" id="L302">                    Administrador admin = adminOpt.get();</span>
<span class="nc" id="L303">                    userAlias = admin.getAlias();</span>

<span class="nc" id="L305">                    ensureNotReused(admin, newPassword);</span>
<span class="nc" id="L306">                    validatePasswordStrength(newPassword, userAlias, userEmail);</span>
<span class="nc" id="L307">                    pushPasswordToHistory(admin);</span>

<span class="nc" id="L309">                    admin.setPassword(encodePassword(newPassword));</span>
<span class="nc" id="L310">                    adminRepository.save(admin);</span>
<span class="nc" id="L311">                    logger.info(&quot;Contrase침a guardada exitosamente para Administrador: {}&quot;, userEmail);</span>
<span class="nc" id="L312">                    userFound = true;</span>
                }
            }


<span class="pc bpc" id="L317" title="1 of 2 branches missed.">            if (!userFound) {</span>
<span class="fc" id="L318">                throw new ResponseStatusException(HttpStatus.NOT_FOUND, USUARIO_NO_ENCONTRADO);</span>
            }

<span class="nc" id="L321">            tokenRepository.delete(resetToken);</span>

<span class="nc" id="L323">            logger.info(&quot;Contrase침a restablecida exitosamente para usuario: {}&quot;, userEmail);</span>
<span class="nc" id="L324">            return &quot;Contrase침a restablecida exitosamente&quot;;</span>

        } 
<span class="fc" id="L327">        catch (ResponseStatusException e) {</span>
<span class="fc" id="L328">            throw e;</span>
        } 
<span class="fc" id="L330">        catch (Exception e) {</span>
<span class="fc" id="L331">            logger.error(&quot;Error durante el restablecimiento de contrase침a para token {}: &quot;, tokenValue, e);</span>
<span class="fc" id="L332">            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, </span>
                ERROR_INTERNO_RESET);
        }
    }

    public boolean validateResetToken(String tokenValue) {
<span class="fc" id="L338">        boolean isValid = false;</span>
        try {
<span class="fc" id="L340">            Optional&lt;Token&gt; resetToken = tokenRepository.findAll().stream()</span>
<span class="pc bpc" id="L341" title="2 of 6 branches missed.">                .filter(t -&gt; t.getTokenCreado() != null &amp;&amp; t.getTokenCreado().equals(tokenValue) &amp;&amp; t.getTipoToken() == TipoToken.RECUPERACION_PASSWORD)</span>
<span class="fc" id="L342">                .findFirst();</span>
            
<span class="fc bfc" id="L344" title="All 2 branches covered.">            if (resetToken.isPresent()) {</span>
<span class="fc" id="L345">                Token token = resetToken.get();</span>
                
<span class="fc bfc" id="L347" title="All 2 branches covered.">                if (token.isValido()) {</span>
<span class="fc" id="L348">                    isValid = true;</span>
                } 
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">                else if (token.isExpirado()) {</span>
<span class="fc" id="L351">                    tokenRepository.delete(token);</span>
                }
            }
        } 
<span class="fc" id="L355">        catch (Exception e) {</span>
<span class="fc" id="L356">            logger.error(&quot;Error validando token de recuperaci칩n:&quot;, e);</span>
<span class="fc" id="L357">        }</span>
<span class="fc" id="L358">        return isValid;</span>
    }


    private String generateResetToken() {
<span class="fc" id="L363">        SecureRandom random = new SecureRandom();</span>
<span class="fc" id="L364">        byte[] bytes = new byte[32];</span>
<span class="fc" id="L365">        random.nextBytes(bytes);</span>
<span class="fc" id="L366">        return Base64.getUrlEncoder().withoutPadding().encodeToString(bytes);</span>
    }

    private void validatePasswordStrength(String password, String alias, String email) {
        
<span class="pc bpc" id="L371" title="1 of 2 branches missed.">        if (password.toLowerCase().contains(alias.toLowerCase())) {</span>
<span class="nc" id="L372">            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, </span>
                &quot;La contrase침a no debe contener el alias de usuario&quot;);
        }

<span class="pc bpc" id="L376" title="2 of 4 branches missed.">        if (email != null &amp;&amp; password.toLowerCase().contains(email.split(&quot;@&quot;)[0].toLowerCase())) {</span>
<span class="nc" id="L377">            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, </span>
                &quot;La contrase침a no debe contener el nombre del correo electr칩nico&quot;);
        }
        
        // Verificaci칩n contra diccionario de contrase침as comunes
<span class="pc bpc" id="L382" title="1 of 2 branches missed.">        if (passwordSecurityService.isPasswordInDictionary(password)) {</span>
<span class="nc" id="L383">            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, </span>
                &quot;La contrase침a seleccionada es demasiado com칰n. Por favor, elige una contrase침a m치s segura.&quot;);
        }
        
        // Verificaci칩n contra brechas de datos p칰blicas
<span class="pc bpc" id="L388" title="1 of 2 branches missed.">        if (passwordSecurityService.isPasswordLeaked(password)) {</span>
<span class="nc" id="L389">            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, </span>
                &quot;La contrase침a seleccionada ha sido comprometida en brechas de datos p칰blicas. &quot; +
                &quot;Por tu seguridad, por favor selecciona una contrase침a diferente.&quot;);
        }
        
<span class="fc" id="L394">        logger.info(&quot;Validaci칩n de contrase침a completada exitosamente para usuario con email: {}&quot;, email);</span>
<span class="fc" id="L395">    }</span>

    private String encodePassword(String password) throws SecurityException {
<span class="fc" id="L398">        String passwordWithPepper = password + pepper;</span>
<span class="fc" id="L399">        int memory = 65536;</span>
<span class="fc" id="L400">        int iterations = 3;</span>
<span class="fc" id="L401">        int parallelism = 1;</span>
<span class="fc" id="L402">        String hash = argon2.hash(iterations, memory, parallelism, passwordWithPepper.toCharArray());</span>
<span class="fc" id="L403">        argon2.wipeArray(passwordWithPepper.toCharArray());</span>
<span class="fc" id="L404">        return hash;</span>
    }

    private boolean matchesPassword(String rawPassword, String encodedPassword) {
<span class="fc" id="L408">        logger.info(&quot;Verificando contrase침a con pepper: {}&quot;, pepper);</span>
<span class="fc" id="L409">        String passwordWithPepper = rawPassword + pepper;</span>
<span class="fc" id="L410">        return argon2.verify(encodedPassword, passwordWithPepper.toCharArray());</span>
    }

    private void ensureNotReused(Usuario user, String newPassword) {
        // 1) No puede ser igual a la actual
<span class="fc bfc" id="L415" title="All 2 branches covered.">        if (matchesPassword(newPassword, user.getPassword())) {</span>
<span class="fc" id="L416">            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, CONTRASENA_DIFERENTE_REQUERIDA);</span>
        }

        // 2) No puede ser igual a ninguna de las 칰ltimas N
<span class="pc bpc" id="L420" title="1 of 2 branches missed.">        if (user.getPasswordHistory() != null) {</span>
<span class="pc bpc" id="L421" title="1 of 2 branches missed.">            for (String oldHash : user.getPasswordHistory()) {</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">                if (matchesPassword(newPassword, oldHash)) {</span>
<span class="nc" id="L423">                    throw new ResponseStatusException(HttpStatus.BAD_REQUEST, CONTRASENA_REUTILIZADA);</span>
                }
<span class="nc" id="L425">            }</span>
        }
<span class="fc" id="L427">    }</span>

        /**
     * A침ade la contrase침a actual al historial del usuario (m치x 5 registros).
     */
    private void pushPasswordToHistory(Usuario user) {
<span class="fc" id="L433">        String currentHash = user.getPassword();</span>
<span class="pc bpc" id="L434" title="2 of 4 branches missed.">        if (currentHash == null || currentHash.isBlank()) {</span>
<span class="nc" id="L435">            return;</span>
        }

<span class="fc" id="L438">        java.util.List&lt;String&gt; history = user.getPasswordHistory();</span>
<span class="pc bpc" id="L439" title="1 of 2 branches missed.">        if (history == null) {</span>
<span class="nc" id="L440">            history = new java.util.ArrayList&lt;&gt;();</span>
        }

        // Insertar la contrase침a actual al comienzo
<span class="fc" id="L444">        history.add(0, currentHash);</span>

        // Limitar a las 5 m치s recientes
<span class="pc bpc" id="L447" title="1 of 2 branches missed.">        if (history.size() &gt; PASSWORD_HISTORY_LIMIT) {</span>
<span class="nc" id="L448">            history = history.subList(0, PASSWORD_HISTORY_LIMIT);</span>
        }

<span class="fc" id="L451">        user.setPasswordHistory(history);</span>
<span class="fc" id="L452">        user.setPasswordChangedAt(java.time.LocalDateTime.now());</span>
<span class="fc" id="L453">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>